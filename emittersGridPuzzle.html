<!DOCTYPE html>
<html class="loading">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- Not supported by iOS -->
<!--<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />-->
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<title>Emitters Grid Puzzle</title>
<link rel="manifest" crossorigin="use-credentials" href="manifest.json" />
<link rel="stylesheet" href="styles.css" />
<script type="text/javascript" src="common.js"></script>
<script>
  "use strict";
  
  // Quick: 6/6, Casual: 8/8, Challenging: 10/10, Intense: 12/12
  const ROWS = 4 + DIFFICULTY * 2;
  const COLS = 4 + DIFFICULTY * 2;
  const USE_XOR = false;
  const GRID_SIZE = Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) * Math.max(ROWS, COLS) / (Math.max(ROWS, COLS) + 1.5);
  const CELL_SIZE = GRID_SIZE / Math.max(ROWS, COLS);
  const GRID_WIDTH = CELL_SIZE * COLS;
  const GRID_HEIGHT = CELL_SIZE * ROWS;
  const NODE_SIZE = CELL_SIZE / 3;
  const LINE_THICKNESS = 6;
  
  const DIRECTION = Object.freeze({
    "UP": 1,
    "RIGHT": 2,
    "DOWN": 3,
    "LEFT": 4,
  });
  const DIRECTIONS = Object.values(DIRECTION);
  
  const NODE_TYPE = Object.freeze({
    "EMITTER": 1,
    "BLOCK": 2,
    "RECEIVER": 3,
  });
  
  let clinkSound;
  let snapSound;
  let resetSound;
  let chimeSound;
  
  let dragging = null;
  let previousTouch = null;
  let grid;
  let nodes;
  let solution;
  let initialState;
  
  function generateGrid() {
    grid = Array.from({length: COLS}, (el, x) => Array.from({length: ROWS},
        (el, y) => ({
      coord: [x, y]
    })));
    
    let placementFound = false;
    
    while(!placementFound) {
      nodes = [];
      placementFound = true;
      let emitterColIndexes = Array.from({length: ROWS}, (el, y) => y);
      let blockColIndexes = Array.from({length: ROWS}, (el, y) => y);
      let receiverColIndexes = Array.from({length: ROWS}, (el, y) => y);

      for (let i = 0; i < grid.length; i++) {
        let emitterY = randomEl(emitterColIndexes, true);

        let blockY = null;
        let savedIndexes = [];
        
        while (blockColIndexes.length && (blockY === null || blockY === emitterY)) {
          if (blockY !== null) {
            savedIndexes.push(blockY);
          }

          blockY = randomEl(blockColIndexes, true);
        }

        if (blockY === null || blockY === emitterY) {
          placementFound = false;
          break;
        }

        blockColIndexes = blockColIndexes.concat(savedIndexes);

        let receiverY = null;
        savedIndexes = [];
        
        while (receiverColIndexes.length &&
            (receiverY === null || receiverY === emitterY || receiverY === blockY)) {
          if (receiverY !== null) {
            savedIndexes.push(receiverY);
          }

          receiverY = randomEl(receiverColIndexes, true);
        }

        if (receiverY === null || receiverY === emitterY || receiverY === blockY) {
          placementFound = false;
          break;
        }
        
        receiverColIndexes = receiverColIndexes.concat(savedIndexes);
        
        nodes.push({
          type: NODE_TYPE.EMITTER,
          coord: [i, emitterY],
          canvasCoord: gridToCanvasCoord([i, emitterY], true)
        });

        nodes.push({
          type: NODE_TYPE.BLOCK,
          coord: [i, blockY],
          canvasCoord: gridToCanvasCoord([i, blockY], true)
        });

        nodes.push({
          type: NODE_TYPE.RECEIVER,
          coord: [i, receiverY],
          canvasCoord: gridToCanvasCoord([i, receiverY], true),
          directions: []
        });
      }
    }
    
    const MAX_RECEIVERS_PER_SLICE = Math.floor((ROWS + COLS) / 5);
    const MAX_RECEIVERS = Math.floor((ROWS + COLS) * 3 / 4
        + Math.random() * (ROWS + COLS) / 2);
        //(ROWS + COLS) / 4 * MAX_RECEIVERS_PER_SLICE
        //+ Math.floor(Math.random() * ((ROWS + COLS) / 4 * MAX_RECEIVERS_PER_SLICE));
    
    // Add receivers past blocks that are receiving emission to make them relevant
    let preferredCells = [];
    let blocks = nodes.filter(node => node.type === NODE_TYPE.BLOCK);
    blocks.forEach(block => {
      DIRECTIONS.forEach(direction => {
        let foundEmitter = false;

        switch (direction) {
          case DIRECTION.UP:
            for (let i = block.coord[1]; i >= 0; i--) {
              let nodeAtCoord = getNodeAtCoord(block.coord[0], i);

              if (!nodeAtCoord) {
                if (foundEmitter) {
                  preferredCells.push(grid[block.coord[0]][i]);
                }

                continue;
              } else if (nodeAtCoord.type === NODE_TYPE.BLOCK) {
                break;
              } else if (nodeAtCoord.type === NODE_TYPE.EMITTER) {
                foundEmitter = true;
              }
            }

            break;
          case DIRECTION.DOWN:
            for (let i = block.coord[1]; i < ROWS; i++) {
              let nodeAtCoord = getNodeAtCoord(block.coord[0], i);

              if (!nodeAtCoord) {
                if (foundEmitter) {
                  preferredCells.push(grid[block.coord[0]][i]);
                }

                continue;
              } else if (nodeAtCoord.type === NODE_TYPE.BLOCK) {
                break;
              } else if (nodeAtCoord.type === NODE_TYPE.EMITTER) {
                foundEmitter = true;
              }
            }

            break;
          case DIRECTION.LEFT:
            for (let i = block.coord[0]; i >= 0; i--) {
              let nodeAtCoord = getNodeAtCoord(i, block.coord[1]);

              if (!nodeAtCoord) {
                if (foundEmitter) {
                  preferredCells.push(grid[i][block.coord[1]]);
                }

                continue;
              } else if (nodeAtCoord.type === NODE_TYPE.BLOCK) {
                break;
              } else if (nodeAtCoord.type === NODE_TYPE.EMITTER) {
                foundEmitter = true;
              }
            }

            break;
          case DIRECTION.RIGHT:
            for (let i = block.coord[0]; i < COLS; i++) {
              let nodeAtCoord = getNodeAtCoord(i, block.coord[1]);

              if (!nodeAtCoord) {
                if (foundEmitter) {
                  preferredCells.push(grid[i][block.coord[1]]);
                }

                continue;
              } else if (nodeAtCoord.type === NODE_TYPE.BLOCK) {
                break;
              } else if (nodeAtCoord.type === NODE_TYPE.EMITTER) {
                foundEmitter = true;
              }
            }

            break;
          default:
            console.error("Unrecognized direction:", direction);
        }
      });
    });
    
    let colReceiverCount = Array.from({length: COLS}, () => 1);
    let rowReceiverCount = Array.from({length: ROWS}, () => 1);
    let freeCells = grid.flat().filter(cell => {
      return !preferredCells.includes(cell) && !getNodeAtCoord(cell.coord);
    });
    
    for (let i = COLS; i <= MAX_RECEIVERS && (preferredCells.length || freeCells.length); i++) {
      let cell = preferredCells.length ? randomEl(preferredCells, true)
          : randomEl(freeCells, true);

      colReceiverCount[cell.coord[0]]++;
      if (colReceiverCount[cell.coord[0]] >= MAX_RECEIVERS_PER_SLICE) {
        freeCells = freeCells.filter(freeCell => freeCell.coord[0] !== cell.coord[0]);
      }

      rowReceiverCount[cell.coord[1]]++;
      if (rowReceiverCount[cell.coord[1]] >= MAX_RECEIVERS_PER_SLICE) {
        freeCells = freeCells.filter(freeCell => freeCell.coord[1] !== cell.coord[1]);
      }

      nodes.push({
        directions: [],
        type: NODE_TYPE.RECEIVER,
        coord: [...cell.coord],
        canvasCoord: gridToCanvasCoord([...cell.coord], true)
      });
    }
    
    nodes.filter(node => node.type === NODE_TYPE.RECEIVER).forEach(node => {
      let cell = grid[node.coord[0]][node.coord[1]];
      
      node.directions = DIRECTIONS.filter(direction => {
        return isCoordReceivingFromDirection(node.coord, direction);
      });
    });
    
    // Shuffle the data order so the draw order won't reveal the solution.
    // Fixed elements (receivers) should come first so they always show behind.
    let shuffledNodes = nodes.filter(node => node.type === NODE_TYPE.RECEIVER);
    let remainingNodes = nodes.filter(node => node.type !== NODE_TYPE.RECEIVER);
    while (remainingNodes.length > 0) {
      shuffledNodes.push(randomEl(remainingNodes, true));
    }
    
    nodes = shuffledNodes;
    solution = deepCopy(nodes);
    
    setTimeout(finishInit);
  }
  
  function getNodeAtCoord(coord) {
    let nodesToUse = showingSolution ? solution : nodes;
    let matches = nodesToUse.filter(node => {
      return dragging !== node
          && node.coord[0] === coord[0] && node.coord[1] === coord[1];
    });
    
    let emitterMatches = matches.filter(node => node.type === NODE_TYPE.EMITTER);
    return emitterMatches.length ? emitterMatches[0]
        : (matches.length ? matches[0] : null);
  }
  
  function isCoordReceivingFromDirection(coord, direction) {
    switch (direction) {
      case DIRECTION.UP:
        for (let i = coord[1] - 1; i >= 0; i--) {
          let node = getNodeAtCoord([coord[0], i]);
          
          if (node) {
            return node.type === NODE_TYPE.EMITTER;
          }
        }
        
        break;
      case DIRECTION.DOWN:
        for (let i = coord[1] + 1; i < ROWS; i++) {
          let node = getNodeAtCoord([coord[0], i]);
          
          if (node) {
            return node.type === NODE_TYPE.EMITTER;
          }
        }
        
        break;
      case DIRECTION.LEFT:
        for (let i = coord[0] - 1; i >= 0; i--) {
          let node = getNodeAtCoord([i, coord[1]]);
          
          if (node) {
            return node.type === NODE_TYPE.EMITTER;
          }
        }
        
        break;
      case DIRECTION.RIGHT:
        for (let i = coord[0] + 1; i < COLS; i++) {
          let node = getNodeAtCoord([i, coord[1]]);
          
          if (node) {
            return node.type === NODE_TYPE.EMITTER;
          }
        }
        
        break;
      default:
        console.error("Unrecognized direction:", direction);
    }
        
    return false;
  }
  
  function drawInstructions() {
    drawInstructionsHelper("ðŸ“»\uFE0E Emitters Grid Puzzle ðŸ“»\uFE0E",
        ["Place a 4-way emitter and a block in each row/column,",
            "activating each white receiver but no black ones."],
        ["Drag emitters and blocks to move them."]);
  }
  
  function drawPuzzle() {
    let canvas = document.getElementById("puzzleCanvas");
    let context = canvas.getContext("2d");
    
    context.fillStyle = BACKGROUND_COLOR;
    context.fillRect(0, 0, canvas.width, canvas.height);
    
    //context.fillStyle = "#ffffff";
    //context.fillRect(0, 0, GRID_WIDTH, GRID_HEIGHT);
    
    if (!showingSolution && !puzzleEnded) {
      // Reset
      context.font = "bold " + (CELL_SIZE / 4) + "px Arial"
      context.textAlign = "center";
      context.fillStyle = "#ffffff";
      context.strokeStyle = "#ffffff";
      context.lineWidth = LINE_THICKNESS;
      let resetX = CANVAS_WIDTH - CELL_SIZE / 2;
      let resetY = CANVAS_HEIGHT - CELL_SIZE / 2 - CELL_SIZE * 1 / 20;
          
      context.fillText("Reset", resetX,
          resetY + CELL_SIZE / 12 + CELL_SIZE * 8 / 20);

      context.beginPath();
      context.arc(resetX, resetY, CELL_SIZE / 4, Math.PI, 3 / 2 * Math.PI, true);
      context.lineTo(resetX + CELL_SIZE * 0.05, resetY - CELL_SIZE * 0.15);
      context.lineTo(resetX + CELL_SIZE * 0.1, resetY - CELL_SIZE * 0.3);
      context.lineTo(resetX - CELL_SIZE * 0.02, resetY - CELL_SIZE * 0.25);
      context.lineTo(resetX + CELL_SIZE * 0.025, resetY - CELL_SIZE * 0.2);
      context.lineTo(resetX + CELL_SIZE * 0.05, resetY - CELL_SIZE * 0.2);
      context.stroke();
    }
    
    
    context.strokeStyle = "#808080";
    context.lineWidth = LINE_THICKNESS;
    context.lineCap = "square";
    
    for (let i = 0; i < ROWS; i++) {
      context.beginPath();
      context.moveTo(0, (i + 1) * CELL_SIZE);
      context.lineTo(COLS * CELL_SIZE, (i + 1) * CELL_SIZE);
      context.stroke();
    }
    
    for (let i = 0; i < COLS; i++) {
      context.beginPath();
      context.moveTo((i + 1) * CELL_SIZE, 0);
      context.lineTo((i + 1) * CELL_SIZE, ROWS * CELL_SIZE);
      context.stroke();
    }
    
    context.lineCap = "butt";
    let nodesToDraw = showingSolution ? solution : nodes;
    
    let allEmittersInGrid = nodesToDraw.every(node => {
      return node.type !== NODE_TYPE.EMITTER || isNodeInGrid(node);
    });
    
    let allNodesInGrid = nodesToDraw.every(node => isNodeInGrid(node));
    let anyOverlapping = nodesToDraw.some(node => isOverlapping(node));
    let rowsWithSharedEmitters = getSharedRows(NODE_TYPE.EMITTER);
    let rowsWithSharedBlocks = getSharedRows(NODE_TYPE.BLOCK);
    let columnsWithSharedEmitters = getSharedCols(NODE_TYPE.EMITTER);
    let columnsWithSharedBlocks = getSharedCols(NODE_TYPE.BLOCK);
    
    let solved = !dragging && allNodesInGrid && !anyOverlapping
        && !rowsWithSharedEmitters.length && !rowsWithSharedBlocks.length
        && !columnsWithSharedEmitters.length && !columnsWithSharedBlocks.length;
    
    drawEmissions(context);
    context.lineWidth = LINE_THICKNESS;
    
    nodesToDraw.forEach(node => {
      let invalid;
      
      switch(node.type) {
        case NODE_TYPE.RECEIVER:
          context.fillStyle = "#808080";
          //context.beginPath();
          //context.arc(...node.canvasCoord, NODE_SIZE, 0, 2 * Math.PI, false);
          //context.fill();
          context.fillRect(node.canvasCoord[0] - CELL_SIZE / 2, node.canvasCoord[1] - CELL_SIZE / 2, CELL_SIZE, CELL_SIZE);
          
          DIRECTIONS.forEach(direction => {
            let active = node.directions.includes(direction);
            let receiving = isCoordReceivingFromDirection(node.coord, direction);
            let strokeColor = ((!active || allEmittersInGrid) && active !== receiving)
                ? ALERT_COLOR
                : (active && active === receiving ? SUCCESS_COLOR : "#808080");
            
            if (active !== receiving) {
              solved = false;
            }
            
            context.beginPath();
            context.strokeStyle = strokeColor;
            context.fillStyle = active ?
                (/*active === receiving ? SUCCESS_COLOR :*/ "#ffffff") : "#000000";
            let dirCoord;
            
            switch (direction) {
              case DIRECTION.UP:
                dirCoord = [node.canvasCoord[0], node.canvasCoord[1] - CELL_SIZE * 3 / 8 + LINE_THICKNESS];
                break;
              case DIRECTION.DOWN:
                dirCoord = [node.canvasCoord[0], node.canvasCoord[1] + CELL_SIZE * 3 / 8 - LINE_THICKNESS];
                break;
              case DIRECTION.LEFT:
                dirCoord = [node.canvasCoord[0] - CELL_SIZE * 3 / 8 + LINE_THICKNESS, node.canvasCoord[1]];
                break;
              case DIRECTION.RIGHT:
                dirCoord = [node.canvasCoord[0] + CELL_SIZE * 3 / 8 - LINE_THICKNESS, node.canvasCoord[1]];
                break;
              default:
                console.error("Unrecognized direction:", direction);
                return;
            }
            
            context.arc(dirCoord[0], dirCoord[1], CELL_SIZE * 3 / 16 - LINE_THICKNESS / 2, 0, 2 * Math.PI, false);
            context.fill();
            context.stroke();
          });
          
          break;
        case NODE_TYPE.EMITTER:
          invalid = isOverlapping(node) || (isNodeInGrid(node)
              && (rowsWithSharedEmitters.includes(node.coord[1])
              || columnsWithSharedEmitters.includes(node.coord[0])));
          
          if (invalid) {
            solved = false;
          }
          
          drawEmitter(node, context, invalid);
          
          break;
        case NODE_TYPE.BLOCK:
          invalid = isOverlapping(node) || (isNodeInGrid(node)
              && (rowsWithSharedBlocks.includes(node.coord[1])
              || columnsWithSharedBlocks.includes(node.coord[0])));
          
          if (invalid) {
            solved = false;
          }
          
          drawBlock(node, context, invalid);
          
          break;
        default:
          console.error("Unrecognized node type:", node.type);
      }
    });
    
    if (solved) {
      //drawEmissions(context, true);
      
      nodesToDraw.filter(node => node.type === NODE_TYPE.EMITTER).forEach(node => {
        drawEmitter(node, context, false, true);
      });
      
      nodesToDraw.filter(node => node.type === NODE_TYPE.BLOCK).forEach(node => {
        drawBlock(node, context, false, true);
      });
      
      if (interactive) {
        // Cover up the reset button
        context.fillStyle = BACKGROUND_COLOR;
        context.fillRect(CANVAS_WIDTH - CELL_SIZE, CANVAS_HEIGHT - CELL_SIZE,
            CELL_SIZE, CELL_SIZE);
        
        interactive = false;
        puzzleEnded = true;
        
        chimeSound.play();
      }
    } else {
      queuedSounds.forEach(sound => sound.play());
    }

    queuedSounds = [];
  }
  
  function drawEmissions(context, solved = false) {
    context.strokeStyle = solved ? SUCCESS_COLOR : "#ffffff40";
    context.lineWidth = LINE_THICKNESS * 2;
    
    let nodesToDraw = showingSolution ? solution : nodes;
    
    nodesToDraw.forEach(node => {
      let coord = node.coord;
      
      if (node.type === NODE_TYPE.EMITTER && isNodeInGrid(node)) {
        let upIndex = -1;
        let downIndex = ROWS;
        let leftIndex = -1;
        let rightIndex = COLS;
        
        // Up
        for (let i = coord[1] - 1; i >= 0; i--) {
          let node = getNodeAtCoord([coord[0], i]);

          if (node) {
            upIndex = i;
            break;
          }
        }

        // Down
        for (let i = coord[1] + 1; i < ROWS; i++) {
          let node = getNodeAtCoord([coord[0], i]);

          if (node) {
            downIndex = i;
            break;
          }
        }

        // Left
        for (let i = coord[0] - 1; i >= 0; i--) {
          let node = getNodeAtCoord([i, coord[1]]);

          if (node) {
            leftIndex = i;
            break;
          }
        }

        // Right
        for (let i = coord[0] + 1; i < COLS; i++) {
          let node = getNodeAtCoord([i, coord[1]]);

          if (node) {
            rightIndex = i;
            break;
          }
        }
        
        context.beginPath();
        context.moveTo(node.canvasCoord[0],
            upIndex * CELL_SIZE + (upIndex >= 0 ? CELL_SIZE / 2 : CELL_SIZE));
        context.lineTo(node.canvasCoord[0],
            downIndex * CELL_SIZE + (downIndex <= ROWS - 1 ? CELL_SIZE / 2 : 0));
        context.stroke();
        
        context.beginPath();
        context.moveTo(leftIndex * CELL_SIZE + (leftIndex >= 0 ? CELL_SIZE / 2 : CELL_SIZE),
            node.canvasCoord[1]);
        context.lineTo(rightIndex * CELL_SIZE + (rightIndex <= COLS - 1 ? CELL_SIZE / 2 : 0),
            node.canvasCoord[1]);
        context.stroke();
      }
    });
  }
  
  function drawEmitter(node, context, invalid, solved = false) {
    context.lineWidth = LINE_THICKNESS;
    
    context.fillStyle = solved ? SUCCESS_COLOR : (invalid ? ALERT_COLOR : "#808080");
    context.fillRect(node.canvasCoord[0] - NODE_SIZE, node.canvasCoord[1] - NODE_SIZE / 2, NODE_SIZE * 2, NODE_SIZE);
    context.fillRect(node.canvasCoord[0] - NODE_SIZE / 2, node.canvasCoord[1] - NODE_SIZE, NODE_SIZE, NODE_SIZE * 2);

    context.strokeStyle = "#ffffff";
    context.beginPath();
    context.moveTo(node.canvasCoord[0] - NODE_SIZE, node.canvasCoord[1]);
    context.lineTo(node.canvasCoord[0] + NODE_SIZE, node.canvasCoord[1]);
    context.stroke();
    context.beginPath();
    context.moveTo(node.canvasCoord[0], node.canvasCoord[1] - NODE_SIZE);
    context.lineTo(node.canvasCoord[0], node.canvasCoord[1] + NODE_SIZE);
    context.stroke();
    
    context.fillStyle = "#ffffff";
    context.beginPath();
    context.arc(...node.canvasCoord, LINE_THICKNESS * 2, 0, 2 * Math.PI, false);
    context.fill();
  }
  
  function drawBlock(node, context, invalid, solved = false) {
    context.fillStyle = solved ? SUCCESS_COLOR : (invalid ? ALERT_COLOR : "#808080");
    context.fillRect(node.canvasCoord[0] - NODE_SIZE * 3 / 4,
        node.canvasCoord[1] - NODE_SIZE * 3 / 4, NODE_SIZE * 3 / 2, NODE_SIZE * 3 / 2);
  }
  
  function isNodeInGrid(node) {
    return node.type === NODE_TYPE.RECEIVER || (dragging !== node
        && node.canvasCoord[0] > 0 && node.canvasCoord[0] < COLS * CELL_SIZE
        && node.canvasCoord[1] > 0 && node.canvasCoord[1] < ROWS * CELL_SIZE);
  }
  
  function getSharedRows(nodeType) {
    let nodeList = showingSolution ? solution : nodes;
    let rows = nodeList.reduce((result, node, index) => {
      return (node.type === nodeType && isNodeInGrid(node)) ?
          [...result, node.coord[1]] : result;
    }, []);
    
    return [...new Set(rows.filter((row, index) => {
      return rows.indexOf(row) !== index;
    }))];
  }
  
  function getSharedCols(nodeType) {
    let nodeList = showingSolution ? solution : nodes;
    let cols = nodeList.reduce((result, node, index) => {
      return (node.type === nodeType && isNodeInGrid(node)) ?
          [...result, node.coord[0]] : result;
    }, []);
    
    return [...new Set(cols.filter((col, index) => {
      return cols.indexOf(col) !== index;
    }))];
  }
  
  function isOverlapping(node) {
    let nodeList = showingSolution ? solution : nodes;
    
    if (node.type !== NODE_TYPE.RECEIVER) {
      for (let i = 0; i < nodeList.length; i++) {
        let otherNode = nodeList[i];
        if (nodeList.indexOf(otherNode) !== nodeList.indexOf(node)
            && dragging !== node && dragging !== otherNode) {
          let distance =
              Math.sqrt(Math.pow(otherNode.canvasCoord[0] - node.canvasCoord[0], 2)
                  + Math.pow(otherNode.canvasCoord[1] - node.canvasCoord[1], 2));

          if (distance <= NODE_SIZE * 2) {
            return true;
          }
        }
      }
    }
    
    return false;
  }
  
  /***********************************************
   * INIT
   ***********************************************/
  function init() {
    clinkSound = SOUNDS.clink;
    snapSound = SOUNDS.click;
    resetSound = SOUNDS.boing;
    chimeSound = SOUNDS.chime;
  
    // Allow opportunity for loading screen to show
    setTimeout(generateGrid, 100);
  }
  
  function finishInit() {
    let emitters = nodes.filter(node => node.type === NODE_TYPE.EMITTER);
    let blocks = nodes.filter(node => node.type === NODE_TYPE.BLOCK);
    
    emitters.forEach((node, i) => {
      node.canvasCoord = [(i + 1 / 2) * CELL_SIZE, CANVAS_HEIGHT - CELL_SIZE / 2];
      node.coord = canvasToGridCoord(node.canvasCoord);
    });
    
    blocks.forEach((node, i) => {
      node.canvasCoord = [CANVAS_WIDTH - CELL_SIZE / 2, (i + 1 / 2) * CELL_SIZE];
      node.coord = canvasToGridCoord(node.canvasCoord);
    });
    
    initialState = deepCopy(nodes);
    
    drawInstructions();
    
    finishedLoading();
  }
  
  function resetPuzzle() {
    nodes = deepCopy(initialState);
    resetSound.play();
    drawPuzzle();
  }
  
  function onMouseDown(event) {
    // Left click
    if (event.button === 0) {
      if (interactive) {
        dragging = null;
        
        let canvasRect = event.target.getBoundingClientRect();
        let mouseX = event.offsetX * CANVAS_WIDTH / canvasRect.width;
        let mouseY = event.offsetY * CANVAS_HEIGHT / canvasRect.height;
        
        let moveableNodes = nodes.filter(node => node.type !== NODE_TYPE.RECEIVER);
        
        for (let i = moveableNodes.length - 1; i >= 0; i--) {
          let node = moveableNodes[i];
          
          if (Math.sqrt(Math.pow(mouseX - node.canvasCoord[0], 2)
              + Math.pow(mouseY - node.canvasCoord[1], 2)) < CELL_SIZE * 3 / 8) {
            dragging = node;
            return;
          }
        }
        
        if (mouseX > CANVAS_WIDTH - CELL_SIZE && mouseY > CANVAS_HEIGHT - CELL_SIZE) {
          resetPuzzle();
        }
      }
        
    // Middle click
    } else if (event.button === 1) {
      if (dragging) {
        releaseNode(dragging);
        dragging = null;
      }
    
      onMiddleMouseDown();
    }
  }
  
  function onTouchStart(event) {
    if (interactive && (!dragging || event.touches.length === 1)
        && event.changedTouches.length === 1) {
      dragging = null;
      previousTouch = null;
      
      let touch = event.changedTouches[0];
      let canvasRect = event.target.getBoundingClientRect();
      let touchX = (touch.clientX - canvasRect.left) * CANVAS_WIDTH / canvasRect.width;
      let touchY = (touch.clientY - canvasRect.top) * CANVAS_HEIGHT / canvasRect.height;
      
      let moveableNodes = nodes.filter(node => node.type !== NODE_TYPE.RECEIVER);

      for (let i = moveableNodes.length - 1; i >= 0; i--) {
        let node = moveableNodes[i];

        if (Math.sqrt(Math.pow(touchX - node.canvasCoord[0], 2)
            + Math.pow(touchY - node.canvasCoord[1], 2)) < CELL_SIZE / 2) {
          previousTouch = touch;
          dragging = node;
          return;
        }
      }
      
      if (touchX > CANVAS_WIDTH - CELL_SIZE && touchY > CANVAS_HEIGHT - CELL_SIZE) {
        resetPuzzle();
      }
    }
  }
  
  function onMouseMove(event) {
    if (interactive && dragging) {
      // Can happen if mouse down triggered from touch end...
      if (!isNaN(event.movementX) && !isNaN(event.movementY)) {
        let canvasRect = event.target.getBoundingClientRect();

        dragging.canvasCoord[0] += event.movementX / window.devicePixelRatio * CANVAS_WIDTH / canvasRect.width;
        dragging.canvasCoord[1] += event.movementY / window.devicePixelRatio * CANVAS_HEIGHT / canvasRect.height;

        drawPuzzle();
      }
    }
  }
  
  function onTouchMove(event) {
    if (interactive && dragging && previousTouch) {
      let movedTouch;
      let changedTouches = [...event.changedTouches];
      
      for (let i = 0; i < changedTouches.length; i++) {
        if (changedTouches[i].identifier === previousTouch.identifier) {
          movedTouch = changedTouches[i];
          break;
        }
      }
      
      if (movedTouch) {
        let canvasRect = event.target.getBoundingClientRect();
        let movementX = movedTouch.clientX - previousTouch.clientX;
        let movementY = movedTouch.clientY - previousTouch.clientY;
      
        previousTouch = movedTouch;
        
        dragging.canvasCoord[0] += movementX * CANVAS_WIDTH / canvasRect.width;
        dragging.canvasCoord[1] += movementY * CANVAS_HEIGHT / canvasRect.height;

        drawPuzzle();
      }
    }
  }
  
  function onMouseUp(event) {
    // Left click
    if (event.button === 0) {
      if (interactive && dragging) {
        releaseNode(dragging);
        dragging = null;
        
        drawPuzzle();
      }
      
      dragging = null;
      
    // Middle click
    } else if (event.button === 1) {
      onMiddleMouseUp();
    }
  }
  
  function onTouchEnd(event) {
    if (interactive && dragging && previousTouch) {
      let changedTouches = [...event.changedTouches];
      
      for (let i = 0; i < changedTouches.length; i++) {
        if (changedTouches[i].identifier === previousTouch.identifier) {
          previousTouch = null;
          releaseNode(dragging);
          dragging = null;

          drawPuzzle();
          
          return;
        }
      }
    }
  }
  
  function onMouseOut(event) {
    if (interactive && dragging) {
      releaseNode(dragging);
      dragging = null;
      
      drawPuzzle();
    }
    
    dragging = null;
  }

  function releaseNode(node, playSound = true) {
    let xPos = Math.max(NODE_SIZE, Math.min(CANVAS_WIDTH - NODE_SIZE, node.canvasCoord[0]));
    let yPos = Math.max(NODE_SIZE, Math.min(CANVAS_HEIGHT - NODE_SIZE, node.canvasCoord[1]));
    
    if (xPos > 0 && xPos < COLS * CELL_SIZE
        && yPos > 0 && yPos < ROWS * CELL_SIZE) {
      xPos = Math.floor(xPos / CELL_SIZE) * CELL_SIZE + CELL_SIZE / 2;
      yPos = Math.floor(yPos / CELL_SIZE) * CELL_SIZE + CELL_SIZE / 2;
      
      if (playSound) {
        queuedSounds.push(snapSound);
      }
    } else if (playSound) {
      clinkSound.play();
    }
    
    node.canvasCoord = [xPos, yPos];
    node.coord = canvasToGridCoord(node.canvasCoord);
    
    previousTouch = null;
  }
  
  function gridToCanvasCoord(coord, center = false) {
    let centerOffset = center ? CELL_SIZE / 2 : 0;
    return [coord[0] * CELL_SIZE + centerOffset, coord[1] * CELL_SIZE + centerOffset];
  }
  
  function canvasToGridCoord(coord) {
    return [Math.floor(coord[0] / CELL_SIZE), Math.floor(coord[1] / CELL_SIZE)];
  }
</script>
</head>

<body onload="commonInit(); init();">
  <div id="controls" class="sidebar">
    <button onclick="navigateHome()">
      <span tabindex="-1">&#10094;</span>
    </button>
    <button class="larger" onclick="reloadPuzzle()">
      <span tabindex="-1">&#8634;</span>
    </button>
    <button class="larger" id="instructionsButton" onclick="drawInstructions()">
      <span tabindex="-1">?</span>
    </button>
    <button class="larger" id="solutionButton" onclick="solutionToggle()">
      <span tabindex="-1">&#9745;&#xFE0E;</span>
    </button>
  </div>
  <div id="canvasContainer" class="loading">
    <canvas id="puzzleCanvas" oncontextmenu="return false;" onmousedown="onMouseDown(event)" ontouchstart="onTouchStart(event)" onmousemove="onMouseMove(event)" ontouchmove="onTouchMove(event)" onmouseup="onMouseUp(event)" ontouchend="onTouchEnd(event)" onmouseout="onMouseOut(event)"></canvas>
    <button disabled id="startButton" onclick="startButtonClick()">
      <span tabindex="-1"></span>
    </button>
  </div>
  <div id="settings" class="sidebar">
    <!-- Volume -->
    <button id="muteButton" onclick="toggleMuted()">
      <span id="soundIcon" tabindex="-1">&#128266;</span>
      <span id="noSoundIcon" tabindex="-1">&#128264;</span>
    </button>
    <!-- Tongue Out -->
    <button id="difficulty1" class="faded" onclick="setDifficulty(1)">
      <span tabindex="-1">&#128523;</span>
    </button>
    <!-- Thinking -->
    <button id="difficulty2" class="faded" onclick="setDifficulty(2)">
      <span tabindex="-1">&#129300;</span>
    </button>
    <!-- Bracing -->
    <button id="difficulty3" class="faded" onclick="setDifficulty(3)">
      <span tabindex="-1">&#128548;</span>
    </button>
    <!-- Mind Blown -->
    <button id="difficulty4" class="faded" onclick="setDifficulty(4)">
      <span tabindex="-1">&#129327;</span>
    </button>
    <button id="fullScreenButton" onclick="toggleFullScreen()">
      <span id="fullScreenOnIcon" tabindex="-1">&#128241;</span>
      <span id="fullScreenOffIcon" tabindex="-1">&#128244;</span>
    </button>
  </div>
</body>
</html>
