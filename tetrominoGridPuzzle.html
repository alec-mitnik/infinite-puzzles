<!DOCTYPE html>
<html class="loading">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- Not supported by iOS -->
<!--<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />-->
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<title>Tetromino Grid Puzzle</title>
<link rel="manifest" crossorigin="use-credentials" href="manifest.json" />
<link rel="stylesheet" href="styles.css" />
<script type="text/javascript" src="common.js"></script>
<script>
  "use strict";
  
  //// Quick: 5/5/5, Casual: 6/6/7, Challenging: 7/7/10, Intense: 8/8/14
  //const COLS = 4 + DIFFICULTY;
  //const ROWS = 4 + DIFFICULTY;
  //const TILES = 4 + Math.pow(DIFFICULTY, 2) / 2 + DIFFICULTY / 2;
  // Quick: 6/6/7, Casual: 7/6/9, Challenging: 7/7/10, Intense: 8/7/12
  const COLS = 6 + Math.floor(DIFFICULTY / 2);
  const ROWS = 5 + Math.floor((DIFFICULTY + 1) / 2);
  const TILES = 6 + DIFFICULTY + (DIFFICULTY > 1 ? 1 : 0) + (DIFFICULTY > 3 ? 1 : 0);
  const ROTATIONS = false;
  const TETROMINO_SIZE = 4;
  
  const CELL_SIZE = Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) / (Math.max(ROWS, COLS) + 2);
  const CELL_CONNECTION_THICKNESS = CELL_SIZE / 4;
  const LINE_THICKNESS = 12;
  
  let snapSound;
  let rotateSound;
  let chimeSound;
  
  let dragging = null;
  let previousTouch = null;
  let grid;
  let tiles = [];
  let solution;
  
  function generateGrid() {
    grid = Array.from({length: COLS}, () => Array.from({length: ROWS}, () => {
      return {
        occupied: false
      };
    }));
    
    while (tiles.length < TILES) {
      let availableCoords = [];
      
      for (let i = 0; i < COLS; i++) {
        for (let j = 0; j < ROWS; j++) {
          let spot = grid[i][j];
          
          if (!spot.occupied) {
            availableCoords.push([i, j]);
          }
        }
      }
      
      if (availableCoords.length === 0) {
        // Unable to fit enough tiles, so start over
        tiles = [];
        generateGrid();
        return;
      }
      
      let randomCoord = availableCoords.splice(randomIndex(availableCoords), 1)[0];
      grid[randomCoord[0]][randomCoord[1]].occupied = "used";
      let cellCoords = [randomCoord];
      
      for (let i = 1; i < TETROMINO_SIZE; i++) {
        let availableNeighbors = [];
        
        cellCoords.forEach(cellCoord => {
          if (cellCoord[0] > 0 && !grid[cellCoord[0] - 1][cellCoord[1]].occupied) {
            availableNeighbors.push([cellCoord[0] - 1, cellCoord[1]]);
          }
          
          if (cellCoord[0] < COLS - 1 && !grid[cellCoord[0] + 1][cellCoord[1]].occupied) {
            availableNeighbors.push([cellCoord[0] + 1, cellCoord[1]]);
          }
          
          if (cellCoord[1] > 0 && !grid[cellCoord[0]][cellCoord[1] - 1].occupied) {
            availableNeighbors.push([cellCoord[0], cellCoord[1] - 1]);
          }
          
          if (cellCoord[1] < ROWS - 1 && !grid[cellCoord[0]][cellCoord[1] + 1].occupied) {
            availableNeighbors.push([cellCoord[0], cellCoord[1] + 1]);
          }
        });
        
        if (availableNeighbors.length === 0) {
          cellCoords.forEach(cellCoord => {
            grid[cellCoord[0]][cellCoord[1]].occupied = true;
          });
          
          break;
        } else {
          let randomNeighbor = availableNeighbors.splice(randomIndex(availableNeighbors), 1)[0];
          grid[randomNeighbor[0]][randomNeighbor[1]].occupied = "used";
          cellCoords.push(randomNeighbor);
        }
      }
      
      if (cellCoords.length === TETROMINO_SIZE) {
        let tileMinCoordX = cellCoords.reduce((total, coord) => {
          return Math.min(total, coord[0]);
        }, 999);
        let tileMinCoordY = cellCoords.reduce((total, coord) => {
          return Math.min(total, coord[1]);
        }, 999);
        
        let cellObjects = [];
        
        cellCoords.forEach(cellCoord => {
          let cellX = CELL_SIZE * cellCoord[0] + CELL_SIZE/2;
          let cellY = CELL_SIZE * cellCoord[1] + CELL_SIZE/2;
          
          cellObjects.push({
            x: cellX,
            y: cellY,
            coordinates: [cellCoord[0] - tileMinCoordX, cellCoord[1] - tileMinCoordY]
          });
        });
        
        let tileObj = {
          cells: cellObjects
        };
        
        // Shuffle the data so the draw order doesn't hint at the solution
        tiles.splice(randomIndex(tiles), 0, tileObj);
      }
    }
    
    for (let i = 0; i < COLS; i++) {
      for (let j = 0; j < ROWS; j++) {
        let spot = grid[i][j];

        if (spot.occupied === "used") {
          spot.occupied = false;
        } else if (spot.occupied == false) {
          spot.occupied = true;
        }
      }
    }
  }
  
  // Rotates around tile's center
  function rotateTile(tile, playSound = true) {
    let oldTileMinCoordX = tile.cells.reduce((total, cell) => {
      return Math.min(total, cell.coordinates[0]);
    }, 999);
    let oldTileMaxCoordX = tile.cells.reduce((total, cell) => {
      return Math.max(total, cell.coordinates[0]);
    }, 0);
    let oldTileMinCoordY = tile.cells.reduce((total, cell) => {
      return Math.min(total, cell.coordinates[1]);
    }, 999);
    let oldTileMaxCoordY = tile.cells.reduce((total, cell) => {
      return Math.max(total, cell.coordinates[1]);
    }, 0);
    
    tile.cells.forEach(cell => {
      let cellCoord0 = cell.coordinates[0];
      let cellCoord1 = cell.coordinates[1];
      
      cell.coordinates = [TETROMINO_SIZE - 1 - cellCoord1, cellCoord0];
      let deltaX = cell.coordinates[0] - cellCoord0;
      let deltaY = cell.coordinates[1] - cellCoord1;
      cell.x += deltaX * CELL_SIZE;
      cell.y += deltaY * CELL_SIZE;
    });
    
    let newTileMinCoordX = tile.cells.reduce((total, cell) => {
      return Math.min(total, cell.coordinates[0]);
    }, 999);
    let newTileMaxCoordX = tile.cells.reduce((total, cell) => {
      return Math.max(total, cell.coordinates[0]);
    }, 0);
    let newTileMinCoordY = tile.cells.reduce((total, cell) => {
      return Math.min(total, cell.coordinates[1]);
    }, 999);
    let newTileMaxCoordY = tile.cells.reduce((total, cell) => {
      return Math.max(total, cell.coordinates[1]);
    }, 0);
    
    let deltaX = newTileMinCoordX - oldTileMinCoordX + newTileMaxCoordX - oldTileMaxCoordX;
    let deltaY = newTileMinCoordY - oldTileMinCoordY + newTileMaxCoordY - oldTileMaxCoordY;
    
    let moveX = deltaX * CELL_SIZE / 2;
    let moveY = deltaY * CELL_SIZE / 2;

    tile.cells.forEach(cell => {
      cell.x -= moveX;
      cell.y -= moveY;
    });
    
    if (playSound) {
      rotateSound.play();
    }
  }
  
  function puzzleSolved(playSound = true) {
    let solved = !dragging && tiles.reduce((valid, tile) => {
      return valid && !tileIsOverlapping(tile, tiles) && tileHasValidPlacement(tile);
    }, true);
    
    if (interactive && solved && playSound) {
      interactive = false;
      puzzleEnded = true;
      
      chimeSound.play();
    } else {
      queuedSounds.forEach(sound => sound.play());
    }

    queuedSounds = [];
    
    return solved;
  }
  
  function drawInstructions() {
    drawInstructionsHelper("ðŸ”²\uFE0E Tetromino Grid Puzzle ðŸ”²\uFE0E",
        ["Fit all the tetromino pieces into the black area.",
            "Pieces must not overlap each other or the white area."],
        ["Drag the pieces to move them."]);
  }
  
  function drawPuzzle() {
    let canvas = document.getElementById("puzzleCanvas");
    let context = canvas.getContext("2d");
    
    let solved = puzzleSolved();
    
    context.fillStyle = solved || showingSolution ?
        SUCCESS_COLOR : BACKGROUND_COLOR;
    context.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    
    let tilesToDraw = showingSolution ? solution : tiles;
    
    grid.forEach((gridRow, rowIndex) => {
      gridRow.forEach((spot, colIndex) => {
        context.fillStyle = spot.occupied ? "#ffffff" : "#000000"
        context.fillRect(CELL_SIZE * rowIndex, CELL_SIZE * colIndex, CELL_SIZE, CELL_SIZE);
      });
    });
    
    tilesToDraw.forEach(tile => {
      let isOverlapping = tileIsOverlapping(tile, tilesToDraw);
      let validPlacement = tileHasValidPlacement(tile);
      let tileColor = isOverlapping ? ALERT_COLOR : (validPlacement ? SUCCESS_COLOR : "#808080");
    
      context.strokeStyle = tileColor;
      context.lineWidth = CELL_CONNECTION_THICKNESS;
      
      tile.cells.forEach(cell => {
        tile.cells.forEach(otherCell => {
          if (Math.round(Math.abs(cell.x - otherCell.x) + Math.abs(cell.y - otherCell.y)) === Math.round(CELL_SIZE)) {
            context.beginPath();
            context.moveTo(cell.x, cell.y);
            context.lineTo(otherCell.x, otherCell.y);
            context.stroke();
          }
        });
      });
      
      context.lineWidth = LINE_THICKNESS;
      
      tile.cells.forEach(cell => {
        context.beginPath();
        context.fillStyle = "#000000";
        context.strokeStyle = tileColor;
        context.arc(cell.x, cell.y, CELL_SIZE/4, 0, 2 * Math.PI, false);
        context.fill();
        context.stroke();
      });
    });
  }
  
  function tileIsOverlapping(tileToCheck, tilesList) {
    return tileToCheck !== dragging && tilesList.reduce((overlapping, tile) => {
      return overlapping || (tile !== dragging && tile.cells.reduce((overlappingCell, cell) => {
        return overlappingCell || tileToCheck.cells.reduce((cellOverlaps, cellToCheck) => {
          let cellToCheckCoords = getGridCoordinatesForCell(cellToCheck);
          let cellCoords = getGridCoordinatesForCell(cell);
          return cellOverlaps || (cellToCheck !== cell && cellToCheckCoords[0] === cellCoords[0] && cellToCheckCoords[1] === cellCoords[1]);
        }, false);
      }, false));
    }, false);
  }
  
  function tileHasValidPlacement(tile) {
    return tile !== dragging && tile.cells.reduce((valid, cell) => {
      let coords = getGridCoordinatesForCell(cell);
      return valid && coords[0] >= 0 && coords[0] < COLS
          && coords[1] >= 0 && coords[1] < ROWS
          && !grid[coords[0]][coords[1]].occupied;
    }, true);
  }
  
  function getGridCoordinatesForCell(cell) {  
    return [
      Math.floor(cell.x / CELL_SIZE),
      Math.floor(cell.y / CELL_SIZE)
    ];
  }
  
  /***********************************************
   * INIT
   ***********************************************/
  function init() {
    snapSound = SOUNDS.click;
    rotateSound = SOUNDS.warp;
    chimeSound = SOUNDS.chime;
    
    generateGrid();

    solution = deepCopy(tiles);
    
    // Place on bottom or right edge to not obscure the grid
    let bottomEdge = Math.random() < 0.5;
    
    do {
      // Randomize tile orientations and positions
      tiles.forEach(tile => {
        if (ROTATIONS) {
          let tileRotations = Math.floor(Math.random() * 4);
          for (let i = 0; i < tileRotations; i++) {
            rotateTile(tile, false);
          }
        }
        
        let tileMinCoordX = tile.cells.reduce((total, cell) => {
          return Math.min(total, cell.coordinates[0]);
        }, 999);
        let tileMaxCoordX = tile.cells.reduce((total, cell) => {
          return Math.max(total, cell.coordinates[0]);
        }, 0);
        let tileMinCoordY = tile.cells.reduce((total, cell) => {
          return Math.min(total, cell.coordinates[1]);
        }, 999);
        let tileMaxCoordY = tile.cells.reduce((total, cell) => {
          return Math.max(total, cell.coordinates[1]);
        }, 0);
        
        let maxX = CANVAS_WIDTH - CELL_SIZE * (0.5 + tileMaxCoordX - tile.cells[0].coordinates[0]);
        let minX = !bottomEdge ? maxX
            : CELL_SIZE * (0.5 + tile.cells[0].coordinates[0] - tileMinCoordX);
        let moveX = Math.random() * (maxX - minX) + minX - tile.cells[0].x;
        
        let maxY = CANVAS_WIDTH - CELL_SIZE * (0.5 + tileMaxCoordY - tile.cells[0].coordinates[1]);
        let minY = bottomEdge ? maxY
            : CELL_SIZE * (0.5 + tile.cells[0].coordinates[1] - tileMinCoordY);
        let moveY = Math.random() * (maxY - minY) + minY - tile.cells[0].y;

        tile.cells.forEach(cell => {
          cell.x += moveX;
          cell.y += moveY;
        });
        
        bottomEdge = !bottomEdge;
      });
    } while (puzzleSolved());
    
    drawInstructions();
    
    finishedLoading();
  }
  
  function onMouseDown(event) {
    // Left click
    if (event.button === 0) {
      if (interactive) {
        let canvasRect = event.target.getBoundingClientRect();
        let mouseX = (event.clientX - canvasRect.left) * CANVAS_WIDTH / canvasRect.width;
        let mouseY = (event.clientY - canvasRect.top) * CANVAS_HEIGHT / canvasRect.height;
        
        // For-each loops cannot be broken out of!
        // Reverse the order so tiles in front are picked up first.
        for (let i = tiles.length - 1; i >= 0; i--) {
          let tile = tiles[i];
          
          if (!tile.fixed) {
            for (let j = 0; j < tile.cells.length; j++) {
              let cell = tile.cells[j];

              if (Math.abs(mouseX - cell.x) < CELL_SIZE / 2
                  && Math.abs(mouseY - cell.y) < CELL_SIZE / 2) {
                dragging = tile;
                return;
              }
            }
          }
        }
      }
        
    // Right click
    } else if (event.button === 2) {
      if (interactive && dragging && ROTATIONS) {
        rotateTile(dragging);
        
        drawPuzzle();
      }
        
    // Middle click
    } else if (event.button === 1) {
      if (dragging) {
        snapToGrid(dragging);
        dragging = null;
      }
    
      onMiddleMouseDown();
    }
  }
  
  function onTouchStart(event) {
    // Single touch
    if (!dragging && event.changedTouches.length === 1) {
      if (interactive) {
        event.preventDefault();
        
        let touch = event.changedTouches[0];
        let canvasRect = document.getElementById("puzzleCanvas").getBoundingClientRect();
        let touchX = (touch.clientX - canvasRect.left) * CANVAS_WIDTH / canvasRect.width;
        let touchY = (touch.clientY - canvasRect.top) * CANVAS_HEIGHT / canvasRect.height;
        
        // For-each loops cannot be broken out of!
        // Reverse the order so tiles in front are picked up first.
        for (let i = tiles.length - 1; i >= 0; i--) {
          let tile = tiles[i];
          
          if (!tile.fixed) {
            for (let j = 0; j < tile.cells.length; j++) {
              let cell = tile.cells[j];

              if (Math.abs(touchX - cell.x) < CELL_SIZE / 2
                  && Math.abs(touchY - cell.y) < CELL_SIZE / 2) {
                previousTouch = touch;
                dragging = tile;
                return;
              }
            }
          }
        }
      }

    // Double tap
    } else if (dragging && event.touches.length === 2) {
      if (interactive && ROTATIONS) {
        event.preventDefault();
        
        rotateTile(dragging);
        
        drawPuzzle();
      }
    }
  }
  
  function onMouseMove(event) {
    if (interactive && dragging) {
      // Can happen if mouse down triggered from touch end...
      if (!isNaN(event.movementX) && !isNaN(event.movementY)) {
        let canvasRect = event.target.getBoundingClientRect();

        dragging.cells.forEach(cell => {
          cell.x += event.movementX * CANVAS_WIDTH / canvasRect.width;
          cell.y += event.movementY * CANVAS_HEIGHT / canvasRect.height;
        });
      
        drawPuzzle();
      }
    }
  }
  
  function onTouchMove(event) {
    if (interactive && dragging && previousTouch) {
      let movedTouch;
      let changedTouches = [...event.changedTouches];
      
      for (let i = 0; i < changedTouches.length; i++) {
        if (changedTouches[i].identifier === previousTouch.identifier) {
          movedTouch = changedTouches[i];
          break;
        }
      }
      
      if (movedTouch) {
        let canvasRect = document.getElementById("puzzleCanvas").getBoundingClientRect();
        
        // Detect drag-out
        if (movedTouch.clientX < canvasRect.left
            || movedTouch.clientX > canvasRect.right
            || movedTouch.clientY < canvasRect.top
            || movedTouch.clientY > canvasRect.bottom) {
          snapToGrid(dragging);
          dragging = null;
          previousTouch = null;
        } else {
          let movementX = movedTouch.clientX - previousTouch.clientX;
          let movementY = movedTouch.clientY - previousTouch.clientY;

          previousTouch = movedTouch;

          dragging.cells.forEach(cell => {
            cell.x += movementX * CANVAS_WIDTH / canvasRect.width;
            cell.y += movementY * CANVAS_HEIGHT / canvasRect.height;
          });
        }

        drawPuzzle();
      }
    }
  }
  
  function onMouseUp(event) {
    // Left click
    if (event.button === 0) {
      if (interactive && dragging) {
        snapToGrid(dragging);
        dragging = null;
        
        drawPuzzle();
      }
      
      dragging = null;
      
    // Middle click
    } else if (event.button === 1) {
      onMiddleMouseUp();
    }
  }
  
  function onTouchEnd(event) {
    if (interactive && dragging && previousTouch) {
      event.preventDefault();
      
      let changedTouches = [...event.changedTouches];
      
      for (let i = 0; i < changedTouches.length; i++) {
        if (changedTouches[i].identifier === previousTouch.identifier) {
          previousTouch = null;
          snapToGrid(dragging);
          dragging = null;

          drawPuzzle();

          return;
        }
      }
    }
  }
  
  function onMouseOut(event) {
    if (interactive && dragging) {
      snapToGrid(dragging);
      dragging = null;
      
      drawPuzzle();
    }
    
    dragging = null;
  }
  
  function snapToGrid(tile, playSound = true) {
    let xChange;
    let yChange;
    
    tile.cells.forEach(cell => {
      if (!xChange) {
        xChange = Math.floor(cell.x / CELL_SIZE) * CELL_SIZE + CELL_SIZE / 2 - cell.x;
      }
      
      if (!yChange) {
        yChange = Math.floor(cell.y / CELL_SIZE) * CELL_SIZE + CELL_SIZE / 2 - cell.y;
      }
      
      cell.x += xChange;
      cell.y += yChange;
      
      if (cell.x < 0) {
        let offset = Math.ceil((0 - cell.x) / CELL_SIZE) * CELL_SIZE;
        
        tile.cells.forEach(cell => {
          cell.x += offset;
        });
      } else if (cell.x > CANVAS_WIDTH) {
        let offset = Math.ceil((cell.x - CANVAS_WIDTH) / CELL_SIZE) * CELL_SIZE;
        
        tile.cells.forEach(cell => {
          cell.x -= offset;
        });
      }
      
      if (cell.y < 0) {
        let offset = Math.ceil((0 - cell.y) / CELL_SIZE) * CELL_SIZE;
        
        tile.cells.forEach(cell => {
          cell.y += offset;
        });
      } else if (cell.y > CANVAS_HEIGHT) {
        let offset = Math.ceil((cell.y - CANVAS_HEIGHT) / CELL_SIZE) * CELL_SIZE;
        
        tile.cells.forEach(cell => {
          cell.y -= offset;
        });
      }
    });
    
    if (playSound) {
      queuedSounds.push(snapSound);
    }
  }
</script>
</head>

<body onload="commonInit(); init();">
  <div id="controls" class="sidebar">
    <button onclick="navigateHome()">
      <span tabindex="-1">&#10094;</span>
    </button>
    <button class="larger" onclick="reloadPuzzle()">
      <span tabindex="-1">&#8634;</span>
    </button>
    <button class="larger" id="instructionsButton" onclick="drawInstructions()">
      <span tabindex="-1">?</span>
    </button>
    <button class="larger" id="solutionButton" onclick="solutionToggle()">
      <span tabindex="-1">&#9745;&#xFE0E;</span>
    </button>
  </div>
  <div id="canvasContainer" class="loading" ontouchstart="onTouchStart(event)" ontouchmove="onTouchMove(event)" ontouchend="onTouchEnd(event)">
    <canvas id="puzzleCanvas" oncontextmenu="return false;" onmousedown="onMouseDown(event)" onmousemove="onMouseMove(event)" onmouseup="onMouseUp(event)" onmouseout="onMouseOut(event)"></canvas>
    <button disabled id="startButton" onclick="startButtonClick()">
      <span tabindex="-1"></span>
    </button>
  </div>
  <div id="settings" class="sidebar">
    <!-- Volume -->
    <button id="muteButton" onclick="toggleMuted()">
      <span id="soundIcon" tabindex="-1">&#128266;</span>
      <span id="noSoundIcon" tabindex="-1">&#128264;</span>
    </button>
    <!-- Tongue Out -->
    <button id="difficulty1" class="faded" onclick="setDifficulty(1)">
      <span tabindex="-1">&#128523;</span>
    </button>
    <!-- Thinking -->
    <button id="difficulty2" class="faded" onclick="setDifficulty(2)">
      <span tabindex="-1">&#129300;</span>
    </button>
    <!-- Bracing -->
    <button id="difficulty3" class="faded" onclick="setDifficulty(3)">
      <span tabindex="-1">&#128548;</span>
    </button>
    <!-- Mind Blown -->
    <button id="difficulty4" class="faded" onclick="setDifficulty(4)">
      <span tabindex="-1">&#129327;</span>
    </button>
    <button id="fullScreenButton" onclick="toggleFullScreen()">
      <span id="fullScreenOnIcon" tabindex="-1">&#128241;</span>
      <span id="fullScreenOffIcon" tabindex="-1">&#128244;</span>
    </button>
  </div>
</body>
</html>
